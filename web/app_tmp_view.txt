// Non-module setup: pull helpers from globals (works on file://)
const { mapTapsToWords, nudgeWord, clampTime } = window.Mapping;
const { exportJSON, exportCSV, importJSON, autosave, loadAutosave } = window.TapperStorage || {};
const { initTimeline, getSelected, setSelected } = window.Waveform;

const state={
  meta:{title:'',audioName:'',duration:0,countdownSec:3,latencyMs:0,mode:'hold',version:1},
  tracks:{lyrics:[],kick:[],snare:[],guitar:[],extra:[]},
  mapped:{words:[]},
  activeTrack:'lyrics'
};

const audio=document.getElementById('audio');
initTimeline(state,audio);

const els={
  title:document.getElementById('title'),
  url:document.getElementById('audio-url'),
  file:document.getElementById('audio-file'),
  countdown:document.getElementById('countdown'),
  latency:document.getElementById('latency'),
  mode:document.getElementById('mode'),
  activeTrack:document.getElementById('active-track'),
  loadBtn:document.getElementById('load-audio'),
  startBtn:document.getElementById('start'),
  stopBtn:document.getElementById('stop'),
  lyrics:document.getElementById('lyrics'),
  mapBtn:document.getElementById('map'),
  clearLyrics:document.getElementById('clear-lyrics'),
  importBtn:document.getElementById('import-json'),
  exportBtn:document.getElementById('export-json'),
  exportCsvBtn:document.getElementById('export-csv'),
  resetBtn:document.getElementById('reset'),
  status:document.getElementById('status'),
  table:document.querySelector('#events tbody'),
  preview:document.getElementById('preview'),
  clock:document.getElementById('clock'),
  nudgeBtns:[...document.querySelectorAll('#nudge button')],
  undoBtn:document.getElementById('undo'),
  playToggle:document.getElementById('play-toggle'),
  previewMappedBtn:document.getElementById('preview-mapped'),
  backupSec:document.getElementById('backup-sec'),
  backupBtn:document.getElementById('backup-btn'),
  liveStatus:document.getElementById('live-status'),
  liveLyrics:document.getElementById('live-lyrics')
};

// Initial guidance
els.status.textContent='1) Choose/paste audio and click Load audio. 2) Click Start + Countdown. 3) Use Space (hold/tap) and 1/2/3/4 (tap mode).';

els.loadBtn.onclick=()=>loadAudio({file:els.file.files[0], url:els.url.value});
els.startBtn.onclick=()=>start(parseInt(els.countdown.value||'0',10));
els.stopBtn.onclick=stop;
els.mapBtn.onclick=()=>{try{map();}catch(e){els.status.textContent=e.message;}};
els.clearLyrics.onclick=()=>{els.lyrics.value='';};
els.importBtn.onclick=()=>{
  const txt=prompt('Paste JSON');
  if(!txt) return; try{importJSON(state,JSON.parse(txt));updateTable();}catch(e){alert('Invalid JSON');}
};
els.exportBtn.onclick=()=>{const data=exportJSON(state);download('taps.json',data);};
els.exportCsvBtn.onclick=()=>{const data=exportCSV(state);download('taps.csv',data);};
els.resetBtn.onclick=()=>{location.reload();};
els.mode.onchange=()=>{ state.meta.mode=els.mode.value; renderLiveCapture(); };
els.activeTrack.onchange=()=>state.activeTrack=els.activeTrack.value;
els.title.oninput=()=>state.meta.title=els.title.value;
els.latency.oninput=()=>state.meta.latencyMs=parseInt(els.latency.value||'0',10);
els.undoBtn.onclick=()=>{ const arr=state.tracks[state.activeTrack]; if(arr && arr.length){ arr.pop(); updateTable(); }};
els.playToggle.onclick=()=>{ if(audio.paused) audio.play(); else audio.pause(); };
els.previewMappedBtn.onclick=()=>{
  if(!state.mapped.words.length){ els.status.textContent='No mapped words to preview.'; return; }
  const t0=state.mapped.words[0].t0||0;
  audio.currentTime=clampTime(t0, state.meta.duration);
  audio.play();
};
els.lyrics.addEventListener('input',()=>{ renderLiveCapture(); });
els.backupBtn.addEventListener('click',()=>{ backUpAndTrim(); });

// Convenience: auto-load when a file is picked or Enter in URL
els.file.addEventListener('change',()=>{
  if(els.file.files && els.file.files[0]){
    els.status.textContent='Loading audio...';
    loadAudio({file:els.file.files[0]}).catch(()=>{});
  }
});
els.url.addEventListener('keydown',(e)=>{
  if(e.key==='Enter'){
    els.status.textContent='Loading audio...';
    loadAudio({url:els.url.value}).catch(()=>{});
  }
});

function download(name,data){
  const a=document.createElement('a');
  a.href=URL.createObjectURL(new Blob([data]));
  a.download=name; a.click();
}

function loadAudio({file,url}){
  return new Promise((resolve,reject)=>{
    if(!file && !url){ els.status.textContent='Pick a file or paste a URL, then click Load audio.'; return reject(new Error('No source')); }
    if(file){
      const obj=URL.createObjectURL(file);
      audio.src=obj; state.meta.audioName=file.name;
    }else if(url){ audio.src=url; state.meta.audioName=url; }
    audio.onloadedmetadata=()=>{state.meta.duration=audio.duration; updateDurationUI(); resolve();};
    audio.onerror=(e)=>{ els.status.textContent='Audio load error (CORS/URL/autoplay). Try a local file.'; reject(e); };
    // Ensure browser starts fetching metadata immediately
    try{ audio.load(); }catch(_){ }
  });
}

let recording=false;
let lastSpace=null;
function start(count){
  if(recording) return; state.meta.countdownSec=count; let sec=count;
  els.status.textContent='Get ready...';
  if(!state.meta.duration || isNaN(state.meta.duration)){
    els.status.textContent='Load an audio file or URL first.';
    return;
  }
  const int=setInterval(()=>{
    els.status.textContent=sec>0?sec: 'GO';
    if(sec--<=0){clearInterval(int);begin();}
  },1000);
}
function begin(){
  recording=true; state.tracks={lyrics:[],kick:[],snare:[],guitar:[],extra:[]};
  audio.currentTime=0;
  // Attempt to start playback. If blocked, instruct the user to click Play.
  const p=audio.play();
  if(p && typeof p.then==='function'){
    p.catch(()=>{ els.status.textContent='Click Play to start, then use Space.'; });
  }
  els.status.textContent = (state.meta.mode==='hold')
    ? 'HOLD mode: press and hold Space for each word.'
    : 'TAP mode: tap Space for words; 1/2/3/4 for instruments.';
  renderLiveCapture();
}
function stop(){ recording=false; audio.pause(); }

document.addEventListener('keydown',e=>{
  if(!recording) return;
  if(e.code==='Space'){
    e.preventDefault();
    const t=clampTime(audio.currentTime+state.meta.latencyMs/1000, state.meta.duration||Number.MAX_SAFE_INTEGER);
    if(state.meta.mode==='hold'){ lastSpace=t; }
    else state.tracks.lyrics.push({t});
    updateTable();
    renderLiveCapture();
  } else if(state.meta.mode==='tap'){
    const keyMap={'Digit1':'kick','Digit2':'snare','Digit3':'guitar','Digit4':'extra'};
    const track=keyMap[e.code];
    if(track){
      const t=clampTime(audio.currentTime+state.meta.latencyMs/1000, state.meta.duration||Number.MAX_SAFE_INTEGER);
      state.tracks[track].push({t});
      updateTable();
    }
  }
  if(e.code==='Backspace'){
    e.preventDefault();
    const arr=state.tracks[state.activeTrack];
    arr.pop();updateTable();
    renderLiveCapture();
  }
  if(e.code==='KeyR'){
    e.preventDefault();
    backUpAndTrim();
  }
});

document.addEventListener('keyup',e=>{
  if(!recording) return;
  if(state.meta.mode==='hold' && e.code==='Space' && lastSpace!=null){
    const t1=clampTime(audio.currentTime+state.meta.latencyMs/1000, state.meta.duration||Number.MAX_SAFE_INTEGER);
    state.tracks.lyrics.push({t0:lastSpace,t1});
    lastSpace=null; updateTable();
    renderLiveCapture();
  }
});

window.addEventListener('keydown',e=>{ if(e.code==='Space') e.preventDefault(); }, {passive:false});

function updateTable(){
  const tbody=els.table; tbody.innerHTML='';
  for(const [track,arr] of Object.entries(state.tracks)){
    arr.forEach(ev=>{
      const tr=document.createElement('tr');
      const t0=(ev.t0??ev.t).toFixed(3);
      const t1=(ev.t1??ev.t).toFixed(3);
      const dur=(ev.t1? (ev.t1-ev.t0).toFixed(3):'');
      tr.innerHTML=`<td>${track}</td><td>${t0}</td><td>${t1}</td><td>${dur}</td>`;
      tbody.appendChild(tr);
    });
  }
}

function map(){
  const words=els.lyrics.value.trim().split(/\s+/).filter(Boolean);
  if(state.mapped.words?.length){
    const ok=confirm('Remap will overwrite current mapping. Continue?');
    if(!ok) return;
  }
  state.mapped.words=mapTapsToWords(state.meta.mode,state.tracks.lyrics,words,state.meta.duration);
  renderPreview();
}

function renderPreview(){
  const frag=document.createDocumentFragment();
  state.mapped.words.forEach((w,i)=>{
    const span=document.createElement('span');
    span.textContent=w.text+' ';
    span.dataset.index=i;
    span.onclick=()=>{sel=i; setSelected(i);};
    frag.appendChild(span);
  });
  els.preview.innerHTML=''; els.preview.appendChild(frag);
}

els.nudgeBtns.forEach(btn=>{
  btn.addEventListener('click',()=>{
    const idx=getSelected();
    if(idx<0) return;
    nudgeWord(state.mapped.words,idx,parseFloat(btn.dataset.d)*1000,'both',state.meta.duration);
    const seg=state.tracks.lyrics[idx];
    const w=state.mapped.words[idx];
    if(seg){seg.t0=w.t0;seg.t1=w.t1;}
    updateTable();
  });
});

let sel=-1;
function tick(){
  els.clock.textContent='Now: '+audio.currentTime.toFixed(3)+'s' + (state.meta.duration? (' / '+state.meta.duration.toFixed(3)+'s'):'');
  const t=audio.currentTime;
  const i=state.mapped.words.findIndex(w=>t>=w.t0 && t<w.t1);
  if(i!==sel){
    sel=i; [...els.preview.children].forEach((sp,n)=>sp.classList.toggle('active',n===i));
  }
  requestAnimationFrame(tick);
}
requestAnimationFrame(tick);

// Arrow key nudging for selected word
document.addEventListener('keydown',(e)=>{
  // Avoid interfering with input/textarea typing
  const tag=(e.target && e.target.tagName)||'';
  if(tag==='INPUT' || tag==='TEXTAREA') return;
  const idx=getSelected();
  if(idx<0) return;
  if(e.key==='ArrowLeft' || e.key==='ArrowRight'){
    e.preventDefault();
    const base= e.shiftKey ? 50 : 5; // ms
    const sign= e.key==='ArrowLeft' ? -1 : 1;
    nudgeWord(state.mapped.words,idx,sign*base,'both',state.meta.duration);
    const seg=state.tracks.lyrics[idx];
    const w=state.mapped.words[idx];
    if(seg){seg.t0=w.t0;seg.t1=w.t1;}
    updateTable();
  }
});

// Autosave
setInterval(()=>autosave(state),3000);
const saved=loadAutosave(); if(saved) {importJSON(state,saved); updateTable(); renderPreview();}
renderLiveCapture();

// Public API
window.Tapper={
  getState:()=>state,
  loadAudio,
  start:count=>start(count),
  stop,
  mapToLyrics:text=>{els.lyrics.value=text; map();},
  exportJSON:()=>JSON.parse(exportJSON(state)),
  exportCSV:()=>exportCSV(state),
  importJSON:obj=>{importJSON(state,obj); updateTable(); renderPreview();},
  nudgeWord:(i,ms,edge)=>{nudgeWord(state.mapped.words,i,ms,edge,state.meta.duration);}
};

function updateDurationUI(){
  els.clock.textContent='Now: 0.000s / '+(state.meta.duration?state.meta.duration.toFixed(3):'0.000')+'s';
  els.status.textContent='Loaded '+(state.meta.audioName||'audio')+' ('+state.meta.duration.toFixed(3)+'s)';
}

// Live capture render: highlights words as you tap/hold
function renderLiveCapture(){
  const words=els.lyrics.value.trim().split(/\s+/).filter(Boolean);
  const total=words.length;
  const doneCount=state.tracks.lyrics.length;
  const capturingNow = state.meta.mode==='hold' && lastSpace!=null;
  const frag=document.createDocumentFragment();

  if(total){
    let status = `Mapped ${Math.min(doneCount,total)} / ${total}`;
    if(capturingNow && doneCount < total){
      status += ` — capturing: "${words[doneCount]}"`;
    } else if(doneCount < total){
      status += ` — next: "${words[doneCount]}"`;
    } else if(doneCount > total){
      status += ` — ${doneCount-total} extra taps beyond lyrics`;
    }
    els.liveStatus.textContent = status;
  } else {
    els.liveStatus.textContent='';
  }

  for(let i=0;i<total;i++){
    const sp=document.createElement('span');
    sp.textContent=words[i];
    if(i<doneCount){ sp.className='done'; }
    else if(i===doneCount && (recording || capturingNow)){ sp.className='current'; }
    frag.appendChild(sp);
  }
  els.liveLyrics.innerHTML='';
  els.liveLyrics.appendChild(frag);
}
